/*

Мы рассмотрим следующие объекты встроенных типов.
    • Array
    • Date
    • RegExp
    • Мар и WeakМap
    • Set и WeakSet

В отличие от неизменяемых базовых типов, способных содержать только одно представленное значение, объекты могут
представлять несколько значений или сложные значения, а также изменять их в процессе существования. По сути, объект
это контейнер, и его содержимое может измениться со временем (это будет тот же объект с другим содержимым).

Содержимое объекта называется свойствами (properties) или членами (members), а свойства состоят из имен.и (или ключа)
и значения. Имена свойств должны быть строками или символами, а значения могут иметь любой тип (включая другие объекты)

Как и массивы, объекты в JavaScript - это контейнеры, которые называют агрегатными или комплексными типами данных.
У объектов есть два основных отличия от массивов:
    1. Массивы содержат значения, индексированные в числовой форме; объекты содержат свойства, индексированные
    строкой или символом.

    2. Массивы упорядочены (элемент arr[0] всегда следует перед arr[1]); объекты не упорядочены
    (вы не можете гарантировать, что свойство obj.а расположено перед obj.b).
Эти различия носят довольно эзотерический (но важный) характер, поэтому давайте считать свойства тем, что делает
объекты по настоящему особенными. Свойство (property) состоит из ключа (key) (строки или символа) и значения (value).
Особенными объекты делает то, что вы можете обращаться к свойствам по их ключам.
*/

const A = Symbol("8");

// Создание пустого объекта
const obj = {};

//Добавление свойств в объект
obj.size;
obj.color = "yellow";

//Изменение значения свойства или добавление свойства и значения
obj["number"] = 3;
obj[A] = 8;

// Создание объекта с значениями

const sam = {
    name: 'Sam',
    age:4,
};

const sam1 = {
        name:'Sam',
        classification: {
            kingdom: 'Anamalia',
            phylum: 'Chordata',
            class: 'Mamalia',
            order: 'Carnivoria',
            family: 'Felidae',
            subfaimily: 'Felinae',
            genus: 'Felis',
            species: 'catus'
        }
};

// Удаление свойства из объекта
delete sam1.classification;


//--------------------------ПЕРЕБОР СВОЙСТ ОБЪЕКТА--------------------------------------------------------------------

/* Первое, что необходимо помнить о переборе свойств, - это то, что порядок не гарантируется. Проведя небольшой
эксперимент, вы можете обнаружить, что свойства выводятся в том порядке, в котором они добавляются, и это справедливо
для многих реализаций движка почти всегда. Тем не менее JavaScript не дает никаких гарантий этому, и изменение
реализации движка в любой момент может ликвидировать этот эффект. Поэтому не стоит полагаться на результат эксперимента
и никогда не стоит подразумевать, что порядок свойств будет именно таков.
*/

// Цикл for..in  ------------------------------------------------------------------------------------------------------

const SUM = Symbol();
const obj = {a: 1, b: 2, c: 3, [SUM]: 4};

console.log(obj);

for (let prop in obj) {
    if (!obj.hasOwnProperty(prop)) continue;

    // Свойство SUM не выводится
    console.log(`${prop}: ${obj[prop]}`);
}

// Метод Object.keys - позволяет получить все перечислимые строковые свойства объекта в виде массива-------------------

const SUM = Symbol();
const obj = {a: 1, b: 2, c: 3, [SUM]: 4};

//Этот пример приводит к тому же результату, что и цикл for..in (здесь даже не нужно выполнять проверку с помощью
// метода hasOwnProperty)

Object.keys(obj).forEach(prop => console.log(`${prop}: ${obj[prop]}`));


