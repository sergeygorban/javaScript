/*Некоторые объектно-ориентированные языки поддерживают множественное наследование (multiple inheritance), когда у
одного класса может быть два прямых суперкласса (в отличие от одного суперкласса, у которого, в свою очередь, есть один
суперкласс). Множественное наследование создает риск коллизий (collision) или конфликтов. Таким образом, если нечто
унаследовано от двух родителей и у обоих родителей есть метод greet, то от кого именно он будет унаследован производным
классом? Во многих языках предпочитается одиночное наследование, при котором этой проблемы нет. Но когда мы решаем
реальные задачи, множественное наследование зачастую имеет смысл. Например, автомобили могли бы происходить как от
транспортных средств, так и от "подлежащих страхованию" (вы можете застраховать и автомобиль, и дом, но дом,
безусловно, - не транспортное средство). В языках, где не поддерживается множественное наследование, зачастую
вводится концепция интерфейса (interface), чтобы обойти эту проблему. Класс (Car) может происходить только от одного
родителя (Vehicle), но у него может быть несколько интерфейсов (Insurable, Container и т.д.).
JavaScript - интересный гибрид. Технически это язык одиночного наследования, поскольку поиск по цепи прототипов не
распространяется на несколько родителей, но он предоставляет пути, которые иногда превосходят и множественное
наследование, и интерфейсы (а иногда - нет). Основной механизм решения проблемы множественного наследования - это
концепция примеси (mixin). Примесь позволяет "подмешивать" функциональные возможности по мере необходимости. Поскольку
JavaScript позволяет чрезвычайно много и без контроля типов, вы можете подмешать почти любые функции к любому
объекту в любое время.
*/

class Car {

    constructor(make) {
        this.make = make;
    }
}

class InsurancePolicy {}

function makeInsurable(obg) {

    obg.addInsurancePolicy = function (p) {

        this.insurancePolicy = p;
    };

    obg.getInsurancePolicy = function () {

        return this.InsurancePolicy
    };

    obg.isinsured = function () {
        return !!this.insurancePolicy;
    }
}

const car1 = new Car();
makeInsurable(car1);
car1.addInsurancePolicy(new InsurancePolicy());

//Более универсальный способ

makeInsurable(Car.prototype);
const car2 = new Car("Tesla");
car2.addInsurancePolicy(new InsurancePolicy());

const car3 = new Car("Vaz");
car3.addInsurancePolicy(new InsurancePolicy());
