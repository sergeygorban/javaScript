/*Итератор напоминает закладку: он помогает следить, где вы находитесь. Массив - пример итерируемого (iteraЫe) объекта:
он содержит множество элементов (по аналогии со страницами в книге) и может предоставить итератор (который похож на
закладку).

Генераторы (generator) - это функции, которые используют итератор для контроля своего выполнения. Обычная функция
получает аргументы и возвращает значение, но никакого контроля вызывающая сторона над ней не имеет. Когда вы вызываете
функцию, управление остается у нее до завершения. Генераторы, напротив, позволяют вам контролировать исполнение функции.
Генераторы приносят двоякую пользу. Во-первых, они позволяют контролировать выполнение функции, разделяя ее на
дискретные этапы. Во-вторых, они позволяют взаимодействовать с функцией по мере ее выполнения. Генератор похож на
обычную функцию за двумя исключениями:
    Функция может возвратить (yield) управление вызывающей стороне в любой момент.
    Когда вы вызываете генератор, он не запускается сразу. Вместо этого вы получаете итератор. Функция запускается
    при вызове метода next итератора.

Генераторы (generator) - это функции, которые используют итератор для контроля своего выполнения. Обычная функция
получает аргументы и возвращает значение, но никакого контроля вызывающая сторона над ней не имеет. Когда вы вызываете
функцию, управление остается у нее до завершения. Генераторы, напротив, позволяют вам контролировать исполнение функции.
Генераторы приносят двоякую пользу. Во-первых, они позволяют контролировать выполнение функции, разделяя ее на
дискретные этапы. Во-вторых, они позволяют взаимодействовать с функцией по мере ее выполнения.

Генератор похож на обычную функцию за двумя исключениями:
    • Функция может возвратить (yield) управление вызывающей стороне в любой момент.
    • Когда вы вызываете генератор, он не запускается сразу. Вместо этого вы получаете итератор. Функция запускается
    при вызове метода next итератора.

Генераторы в JavaScript отмечаются звездочками после ключевого слова function; в остальном их синтаксис идентичен
обычным функциям. Если функция является генератором, вы можете использовать ключевое слово yield в дополнение к return.

Как уже упоминалось, генераторы обеспечивают двухстороннюю связь между генератором и его вызывающей стороной. Для этого
используется выражение yield. Помните, что выражения возвращают значение, и выражение yield тоже должно что-то
возвращать. Оно возвращает аргументы (если они есть), предоставленные вызывающей стороной при каждом вызове метода
next итератора генератора.

*/


// Класс с возможностью итерирования ----------------------------------------------------------------------------------
//Протокол итератора (iterator protocol) позволяет стать итерируемым любому объекту.

class Log {

    constructor() {
        this.messages = [];
    }

    add(message) {
        this.messages.push({message: message, timestamp: Date.now()});
    }

    [Symbol.iterator]() {
        return this.messages.values();
    }
}

const log = new Log();
log.add("Первый день на море");
log.add("Видели большую рыбу");
log.add("Видели корабль");

for (let entry of log) {
    console.log(`${entry.message} @ ${entry.timestamp}`);
}


// Создание генератора ------------------------------------------------------------------------------------------------

function* rainbow() {

    yield 'красный';
    yield 'оранжевый';
    yield 'желтый';
    yield 'зеленый';
    yield 'голубой';
    yield 'синий';
    yield 'фиолетовый';
}

const it = rainbow();
console.log(it.next());

for (let color of rainbow()) {
    console.log(color)
}








