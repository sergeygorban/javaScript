/*
Массивы (array) в JavaScript - это объекты специального типа. В отличие от обычных объектов содержимое массива
упорядочено (элемент О всегда следует перед элементом 1), а ключи являются числовыми и последовательными. Массивы
поддерживают много полезных методов, делающих этот тип данных чрезвычайно мощным средством выражения информации.

Массивы в JavaScript обладают следующими свойствами:
    • Размер массива не ограничен; вы можете добавлять и удалять элементы в любое время.
    • Массивы не являются гомогенными; каждый индивидуальный элемент может иметь любой тип.
    • Элементы массива нумеруются от нуля. Таким образом, первый элемент в массиве - элемент 0.

Прежде чем продолжить, давайте вспомним об основах массивов. Массивы (в отличие от объектов) имеют упорядоченный
характер, а числовые индексы их элементов отсчитываются от нуля. Массивы в JavaScript могут быть негомогенными, т.е.
их элементы не обязаны иметь одинаковый тип (из этого следует, что элементами массивов могут быть друrие массивы или
объекты). Литеральные массивы создаются с помощью квадратных скобок, и те же квадратные скобки используются для
доступа к элементам массива по индексу. Каждый массив имеет свойство length, указывающее количество элементов в массиве.
Присвоение значения по индексу, превосходящему размер массива, автоматически приводит к увеличению массива, а
неиспользуемые индексы получают значение undef ined. Для создания массива можно также использовать конструктор Array,
хотя это редко необходимо.

*/


//Создание массива --------------------------------------------------------------------------------------------

const arr1 = [1, 2, 3, 4];
const arr2 = [1, 'two', 3, null];
const arr3 = [[1,2,3], ["Yes", 2]];
const arr4 = [
    {a: "Yes", b: "No"},
    [
        {a: "Yes", b: "No"},
        {a: "Yes", b: "No"}
    ],
    234,
    function () {
        return "Функция"
    },
    "Yes"
];

//Создание массива из нескольких строк
const a3 = [
    "What the hammer? What the chain?",
    "In what furnace was thy brain?",
    "What the anvil ? What dread grasp",
    "Dare its deadly terrors clasp?"
];

//Создание массива из объектов
const a4 = [
    {name: "Ruby", hardness: 9},
    {name: "Ruby1", hardness: 45},
    {name: "Ruby2", hardness: 23}
];

//Создание массива, содержащего массив
const a5 = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
//----------------------------------------------------------------------------------------------------------------

//Доступ к элементам

arr1[0];    // 1
arr1[2];    // 3
arr3[1];    // "Yes", 2
arr4[1][0]; // a: "Yes", b: "No"

//Длина массива

arr1.length; //4
arr4[1].length; //2

// Увеличение размера массива

arr1[5] = 5;
arr1;


// При доступе (не присвоении) по индексу, большему, чем есть в массиве, размер массива *не* изменяется

arr1[10];
arr1;


//Перезапись элемента массива
const arr2 = ['a', 'b', 'c'];
arr2[0] = 234;
arr2[0];

// Преобразование в строку
const ar = [1, true, "hello"];
ar.toString();

// Метод push() - добавляет эдемент в конец массива

const array = [1,2,3,4];
array.push(5);
console.log(array);

// Метод pop() - удаляет последний элемент в массиве

const array1 = [1,2,3,4];
array1.pop();
console.log(array1);

//Метод unshift - добавляет элемент в начало массива

const array2 = [1,2,3,4];
array2.unshift(5);
console.log(array2);

//Метод shift - удаляет первый элемент в массиве

const array3 = [1,2,3,4];
array3.shift();
console.log(array3);

// Метод concat - добавление нескольких элементов в конец массива и возвращает копию массива-----------------------

const array4 = [1,2,3];
console.log(array4.concat(4,5,6));
console.log(array4);

//Если передать методу concat массивы, он разделит их и добавит их элементы в исходный массив.
console.log(array4.concat([4,5,6]));

console.log(array4.concat([4,5],6));

//Обратите внимание, что concat разделяет массивы, предоставленные только непосредственно; он не разделяет массивы в
// этих массивах.
console.log(array4.concat([4, [5,6],7]));
//-----------------------------------------------------------------------------------------------------------------

// Метод slice() - получение подмассива из массива. Первый аргумент - индекс начала подмассива, а второй - индекс его
// конца (не включая указанный элемент). Этот метод позволяет использовать отрицательные индексы для ссылки на элементы
// относительно конца массива, что весьма удобно. Исходный массив не изменяется

const z = [1,2,3,4,5];

console.log(z.slice(3));

console.log(z.slice(2,4));

console.log(z.slice(-2));

console.log(z.slice(1, -2));

console.log(z.slice(-2,-1));

// Метод splice() - изменение массива. Первый аргумент - индекс, с которого должно начинаться изменение;
// второй аргумент - количество удаляемых элементов (если вы не хотите удалять элементы, используйте О), а
// остальные аргументы - это добавляемые элементы.

const z1 = [1,5,7];
z1.splice(1,0,2,3,4);
console.log(z1);

z1.splice(5,0,6);
console.log(z1);

z1.splice(1,2);
console.log(z1);

z1.splice(2,1,'a','b');
console.log(z1);

// Метод copyWithin() - получает последовательность элементов из массива, и копирует по месту, в другую часть массива,
// переписывая любые находящиеся там элементы. Первый аргумент - откуда копировать, второй аргумент - куда копировать,
// а заключительный (необязательный) аргумент - где прекратить копирование. Как и в методе slice, вы можете использовать
// отрицательные числа для индексов начала и завершения; они рассчитываются от конца массива.

const z2 = [1,2,3,4];

z2.copyWithin(1,2);
console.log(z2);

z2.copyWithin(2,0,2);
console.log(z2);

z2.copyWithin(0, -3, -1);
console.log(z2);

const z2 = [1,2,3,4];
z2.copyWithin(0,0);
console.log(z2);

// Метод fill() - позволяет задать любое количество элементов с фиксированным значением (по месту). Он особенно полезен,
// когда используется вместе с конструктором Array (который позволяет определить начальный размер массива).
// Вы можете произвольно задать начальный и конечный индексы, если хотите заполнить только часть массива (
// отрицательные индексы работают как обычно)

const z3 = new Array(5).fill(1);
console.log(z3);

z3.fill("a");
console.log(z3);

z3.fill("b",1);
console.log(z3);

z3.fill("c", 2,4);
console.log(z3);

z3.fill(5.5,-4);
console.log(z3);

z3.fill(0,-3.-1);
console.log(z3);

// Метод reverse() -  изменяет порядок элементов массива на обратный

const z4 = [1,2,3,4,5,6];
z4.reverse();
console.log(z4);

// Метод sort - сортирует массив--------------------------------------------------------------------------------------

const z5 = [2,5,0,-1,4,3];
z5.sort();
console.log(z5);

//Метод sort позволяет также определить функцию сортировки (sort function), которая может оказаться весьма удобной.
// Например, для сортировки объектов нет однозначного способа.

const z6 = [
    { name: "Вася"},
    { name: "Шиви"},
    { name: "Петя"}];

z6.sort((a,b) => a.name > b.name);
console.log(z6);

// Сортировка по 2 символу в свойстве name

z6.sort((a,b) => a.name[1] < b.name[1]);
console.log(z6);

//---------------------------------------------------------------------------------------------------------------------

// Метод indexOf() - просто возвращает индекс первого найденного элемента, строго равного искомому. Если соответствий
// не найдено возвращает -1

const o = { name: "Jerry"};
const z7 = [1,5,"a",0,true,5,[1,2],"9"];

z7.indexOf(5);
z7.indexOf("a");
z7.indexOf({ name: "Jerry"});
z7.indexOf(0);
z7.indexOf([1,2]);
z7.indexOf(5);

// Чтобы выполнять поиск только в части массива, можно определить необязательный индекс начала

z7.indexOf("a",5);
z7.indexOf(5,5);
z7.indexOf(true,3);

// Метод lastIndexOf() - выполняет поиск в обратном порядке

// Метод findIndex() - подобен методу indexOf в том, что возвращает индекс (или - 1 при отсутствии соответствия), но
// более гибко. Он позволяет задать функцию, которая определяет, является ли элемент соответствующим

const z8 = [{id: 5, name: "Jon"}, {id: 6, name: "Pit"}];
z8.findIndex(o => o.id === 5);

//Метод find - похож на findIndex тем, что позволяет определять функцию для поиска, но возвращает сам элемент, а не
// индекс (или null, если элемент не был найден).

const z9 = [{id: 5, name: "Jon"}, {id: 6, name: "Pit"}];
console.log(z9.find(o => o.id === 5));

// Для findIndex и find
const z10 = [1,2,3,4,5,6];
console.log(z10.find((x,i) => i > 2 && Number.isInteger(Math.sqrt(x))));

// Использование this в findIndex и find. Это может быть очень удобно, если вам нужно вызвать функцию, как будто она
// является методом объекта.

class Person {
    constructor(name) {
        this.name = name;
        this.id = Person.nextid++;
    }
}

Person.nextid = 0;
const jamie =  new Person("Jamie"),
    juliet = new Person("Juliet"),
    peter = new Person("Peter"),
    jay = new Person("Jay");
const arr = [jamie, juliet, peter, jay];

//Прямое сравнение идентификаторов
console.log(arr.find(p => p.id === juliet.id));

// Использование аргумента this
console.log(arr.find(p => p.id === this.id, juliet));


// Метод some() - возвращает true, если находит элемент, который соответствует критерию (это все, что нужно,
// дальнейший поиск сразу прекращается), и false в противном случае.

const z11 = [1,2,3,4,5,6];
console.log(z11.some(a => a ===5));

// Метод every - возвращает true, если каждый элемент в массиве удовлетворяет критерию, и false в противном случае.
// Он прекращает поиск и возвращает false, как только найдет элемент, не соответствующий критерию; в противном случае
// он должен будет просмотреть весь массив.

const z12 = [4,6,16,32];
console.log(z12.every(a => a % 2 === 0));

//Как и все методы, которым передается проверочная функция, some и every имеют второй параметр, который позволяет вам
// определить значение this при вызове функции.

// Метод map() - Метод map преобразует элементы в массиве. Во что? Это вам решать. У вас есть объекты, которые содержат
// числа, а вам нужны именно сами числа? Легко! Ваш массив содержит функции, а нужны возвращаемые ими значения? Легко!
// Всякий раз, когда массив находится в одном формате, а необходим другой, используйте метод map. Методы map
// возвращает копию и не изменяет исходный массив.


const z13 = [{id: 5, name: "Jon"}, {id: 6, name: "Pit"}];
const name = z13.map(x => x.name);
console.log(name);

const name1 = z13.map(x => x.name.toUpperCase());
console.log(name1);

// Использование индексов в методе map
const items = [ "Widget", "Gadget"];
const prices = [9.95, 22.95];

const cart = items.map((x, i) => ({name:x, price: prices[i]}));
console.log(cart);

prices.filter()

// Метод filter() - работает аналогично map, но только удаляет данные из массива

// Метод reduce() -  используется для сведения (reduce) массива к единому значению. -----------------------------------
// Например, суммирование чисел,
// хранящихся в массиве, или вычисление их среднего являются способами свести массив к единому значению.

//Суммирование чисел в массиве

const z13 = [5,7,2,4];
const summ = z13.reduce((a,x) => a += x, 0);
console.log(summ);


