/* Объектно-ориентированное программирование (ООП, Object-Oriented Programming) - старая добрая парадигма в информатике.
Некоторые из концепций, которые мы теперь знаем как ООП, появились еще в 1950-х годах, но только после появления языков
программирования Simula 67 и Smalltalk они обрели форму ООП. Фундаментальная идея проста и интуитивно понятна: объект -
это логически связанная коллекция данных и функций. Она призвана отразить наше понимание естественного мира.
*/

// Создание класса --------------------------------------------------------------------------------------------------

class Car {

    constructor(make, model) {

        this.make = make;
        this.model = model;
        this.userGears = ['P', 'N', 'R', 'D'];
        this.userGear = this.userGears[0];
    }

    shift(gear) {

        if (this.userGears.indexOf(gear) < 0) {
            throw new Error(`Ошибочная передача: ${gear}`);
        }

        this.userGear = gear;
    }
}


// Создание экземпляра класса ------------------------------------------------------------------------------------

const car1 = new Car("Tesla", "Model S");
const car2 = new Car("Mazda", "6");
car1.shift('D');
car2.shift('R');
car2.shift('W');

car1 instanceof Car; // True
car1 instanceof Array; // False

// Динамические свойства ------------------------------------------------------------------------------------------

/*То, что метод shift нашего класса Car предотвращает выбор недопустимой передачи по небрежности, может казаться
очень умным ходом. Но эта защита ограничена, поскольку нет ничего, что помешало бы установить значение
непосредственно: carl.userGear = 'Х'. Большинство объектно-ориентированных языков идет на большие затраты, чтобы
предоставить механизмы защиты от этого вида неправильного обращения, разрешая вам определять уровень доступа к методам
и свойствам. В JavaScript такого механизма нет, за что его нередко и критикуют.
Динамические свойства способны несколько сгладить этот недостаток. Они обладают семантикой свойств с
функциональными возможностями методов. Давайте изменим наш класс Car так, чтобы использовать это в своих интересах.*/

class Car {

    constructor(make, model) {

        this.make = make;
        this.model = model;
        this._userGears = ['P', 'N', 'R', 'D'];
        this._userGear = this._userGears[0];
    }

    getUserGiar() {
        return this._userGear;
    }

    setUserGiar(gear) {

        if (this._userGears.indexOf(gear) < 0) {
            throw new Error(`Ошибочная передача: ${gear}`);
            this._userGear = gear;
        }
    }

    shift(gear) {
        this.userGear = gear;
    }
}

/*Проницательный читатель заметил, что мы не устранили проблему, поскольку значение _userGear все еще можно установить
непосредственно: carl._userGear ='Х'. В этом примере мы используем "ограничение доступа для бедных" - свойства,
имена которых начинаются с символа подчеркивания, мы считаем закрытыми. Эта защита сугубо в соглашении, позволяющем
быстро просмотреть код и выявить свойства, к которыми вы не должны обращаться непосредственно. Если вы действительно
должны обеспечить конфиденциальность, то можете использовать экземпляр WeakMap, который защищен областью видимости
(если мы не будем использовать WeakMap, то наши закрытые свойства никогда не будут выходить из области видимости,
даже если экземпляры, к которым они относятся, выйдут). Чтобы сделать основное текущее свойство передачи действительно
закрытым, мы можем изменить свой класс Car так.*/


const Car = (function () {

    const carProps = new WeakMap();

    class Car {

        constructor(make, model) {

            this.make = make;
            this.model = model;
            this._userGears = ['P', 'N', 'R', 'D'];
            carProps.set(this, {userGear: this._userGears[0]});
        }

        getUserGiar() {
            return carProps.get(this).userGear;
        }

        setUserGiar(gear) {

            if (this._userGears.indexOf(gear) < 0) {
                throw new Error(`Ошибочная передача: ${gear}`);
                carProps.get(this).userGear = gear;
            }
        }

        shift(gear) {
            this.userGear = gear;
        }
    }

    return Car;
    
}) ();

/*Чтобы поместить наш WeakMap в замкнутое выражение, к которому нельзя обратиться извне, мы используем немедленно
вызываемое функциональное выражение. Теперь WeakМap может безопасно хранить любые свойства, к которым
мы не хотим обращаться за пределами класса.*/


// toString - возвращает строковое представление объекта--------------------------------------------------------------

class Car {
    constructor(make) {
        this.make = make;
    }
}

console.log(new Car("Mazda").toString()); //[object Object]

// Переопределение метода toString()

class Car {
    constructor(make) {
        this.make = make;
    }

    toString() {
        return `${this.make}`;
    }
}

console.log(new Car("Mazda").toString()); //Mazda

//--------------------------------------------------------------------------------------------------------------------