/*
Функция (function) - это самодостаточный набор операторов, выполняющийся как единый блок; по существу, можно считать
ее подпрограммой. Функции - это основа мощи и выразительности языка JavaScript. В данной главе описаны основы их
применения и соответствующие механизмы. У каждой функции есть тело (body) - набор составляющих функцию операторов.

Функции в JavaScript являются объектами и могут быть переданы и присвоены подобно любым другим объектам. Важно
понимать различие между вызовом (calling) функции и просто обращением (referencing) к ней. Когда за идентификатором
функции следуют круглые скобки, JavaScript знает, что осуществляется вызов: выполняется тело функции и выражение
возвращает значение. Без круглых скобок вы просто обращаетесь к функции, как к любому другому значению, а это не вызов.
Возможность обращения к функции, как к любому другому значению (не вызывая ее), обеспечивает большую гибкость языка.
Например, вы можете присвоить функцию переменной, что позволит вызвать функцию под другим именем.

Основной механизм передачи информации при вызове функции - это аргументы (argument) функции (иногда называемые ее
параметрами (parameter)). Аргументы похожи на переменные, которые не существуют, пока функция не будет вызвана

Вы можете вызвать любую функцию с любым количеством аргументов. Если при вызове функции вы не укажете
аргументы, то им неявно присваивается значение undefined.

Нововведением ЕSб является способность определять стандартные значения (default value) для аргументов. Обычно, когда
значения для аргументов не заданы, им присваивается значение undefined. С помощью стандартных значений можно определить
некое другое значение для тех аргументов, которые не были переданы в функцию.

Обычно ключевое слово this имеет отношение к функциям, являющимся свойствами объектов. При вызове метода переменной
this присваивается значение конкретного объекта, в котором произошел вызов.

До сих пор мы имели дело исключительно с объявлениями функций (function declaration), которые присваивают функции и
тело (т.е. то, что функция делает), и идентификатор (он позволяет впоследствии вызывать функцию по имени). JavaScript
поддерживает также анонимные функции (anonymous function), у которых не обязательно есть идентификатор. У вас может
возникнуть резонный вопрос "Как использовать функцию, у которой нет идентификатора? Как мы должны вызывать ее без
идентификатора?" Ответ кроется в понятии функциональных выражений (function expression). Известно, что выражение - это
нечто, что вычисляет значение, и мы также знаем, что функция - это также значение, как и все остальное в JavaScript.
Функциональное выражение - это просто средство для того, чтобы объявить (возможно, безымянную) функцию. Функциональное
выражение может быть присвоено чему-нибудь (в результате ему будет назначен идентификатор) или сразу же вызвано2•
Функциональные выражения синтаксически идентичны объявлениям функций, за исключением того, что вы можете опустить имя
функции.

СТРЕЛОЧНАЯ НОТАЦИЯ

В спецификацию ЕSб введен новый долгожданный синтаксис стрелочной нотации (arrow notation). Это чрезвычайно полезный
синтаксис (он имеет одно серьезное функциональное отличие, до которого мы вскоре дойдем), который существенно экономит
время на вводе слова funct ion, а также сокращает количество фигурных скобок, которые нужно ввести. Стрелочные функции
позволяют упростить синтаксис тремя способами:

    • Опустить слово function.
    • Если функции передается один аргумент, опустить круглые скобки.
    • Если тело функции - одно выражение, опустить фигурные скобки и оператор return.
Стрелочные функции всегда являются анонимными. Вы вполне можете присвоить их переменной, но не можете создать
именованную функцию, как в случае использования ключевого слова function.

У стрелочных функций действительно есть одно серьезное отличие от обычных функций: переменная this привязывается
лексически, точно так же, как и любая другая переменная.
Стрелочные функции не могут использоваться как конструктор

НЕМЕДЛЕННО ВЫЗЫВАЕМЫЕ ФУНКЦИОНАЛЬНЫЕ ВЫРАЖЕНИЯ

Функциональные выражения позволяют создавать немедленно вызываемые функциональные выражения (Immediately Invoked
Function Expression - IIFE). IIFE объявляет функцию, а затем немедленно ее запускает.



*/

// Создание функции
function hello() {
    console.log("Hello!");
}

// Вызов функции
hello();

// Функция, которая возвращает значение
function getName() {
    return "Бо";
}
getName();

// Обращение к функции
getName;

// Присвоение функции переменной и вызов
const newName = getName;
newName();

// Присвоение функции свойству объекта и вызов
const obj = {};
obj.fun = getName;
obj.fun();

// Создание функции в объекте
const s = {
    name: function () {
        return "Valar";
    },
    age: 234
};

s.name();

//В спецификацию ЕSб введен новый сокращенный синтаксис для методов. Следующее функционально эквивалентно
// предыдущему примеру.
const s1 = {
    name() {
        return "Valar";
    },
    age: 234
};

s1.name();



// Добавление функции в массив и вызов
const arr = [1, 2, 3];
arr[1] = getName;
arr[1]();

// Создание функции с параметрами и вызов. В этом объявлении функции а и Ь - это формальные аргументы (formal argument).
// При вызове функции формальные аргументы получают значения и становятся фактическими аргументами (actual argument).
function avg(a,b) {
    return(a + b)/2;
}
avg(12,12);

// Переменные примитивных типов не изменяются внутри функции
function rep(a) {
    return a + 10;
}

let a = 23;
console.log(rep(3));
console.log(a);

// Объекты изменяются внутри функции
function addToObj(obj1) {
    obj1.prop = 100;
    return obj1;
}

const obj1 = {};
console.log(addToObj(obj1));
console.log(obj1);

// Вызов функции, не передавая аргумент

function sas(a) {
    return a;
}
sas();
sas(1,2,3);

// Значения по умолчанию, если не переданы
function def(a = "def", b = "defau", c = "default") {
    return `${a} - ${b} - ${c}`;
}

def();
def(1,2);

// Ключевое слово this ---------------------------------------------------------------------------------------------
const o = {
    name: 'Wallace',
    speak() {return `Меня зовут ${this.name}!`;}
};

//Когда происходит вызов о.speak(),переменная this будет связана с объектом o.
o.speak();

//Важно понимать, что this связывается согласно тому, как функция вызвана, а не где объявлена. Таким образом, this
// связана с о не потому, что speak - это свойство о, а потому, что мы вызвали этот метод непосредственно из о(о.speak).
// Давайте рассмотрим, что будет, если мы присвоим ту же функцию переменной.

const speak = o.speak;
speak === o.speak;

//В связи с другим способом вызова функции движок JavaScript не знает, что функция была первоначально объявлена в о;
// таким образом, переменной this было присвоено значение undefined.
speak();
//-------------------------------------------------------------------------------------------------------------------

//this и вложенные функции

const obj2 = {

    nameFirst: "Призрачный",
    fullName: function () {
        function create() {
            let name = this.nameFirst + " " + "Самогонщик";
            return name;
        }
        return `${create()}`;
    }
};

obj2.fullName(); // "undefined Самогонщик"

// чтобы решить проблему, необходимо выполнить следующее

const obj3 = {

    nameFirst: "Призрачный",
    fullName: function () {
        const self = this;
        function create() {
            let name = self.nameFirst + " " + "Самогонщик";
            return name;
        }
        return `${create()}`;
    }
};
obj3.fullName(); //"Призрачный Самогонщик"

//-------------------------------------------------------------------------------------------------------------------

// Функциональные выражения и анонимные функции

//Создание функционального выражения без имени и присвоение переменной
const f = function () {
    return "Самогонщик";
};
f();

// Создание функционального выражения с именем. Это может быть необходимо, если нужно обратиться к функции из самой
// функции (так называемая рекурсия (recursion)).

const f1 = function getName() {
    return "Самогонщик";
};
f1(); // Самогонщик
getName(); // Ошибка

// Рекурсия
const g = function f(stop) {
    if (stop) console.log ('f остановлена');
    f(true);
};
g(false);

//--------------------------------------------------------------------------------------------------------------------

//Стрелочная нотация

const fun = function () {
    return "Самогонщик";
};
// или
const fun1 = () => "Самогонщик";
fun1();

const fun2 = function (name) {
    return name;
};
fun2("Хулио");
// или
const fun3 = name => name;
fun3("Хулио");

const fun4 = function (name, age) {
    return name + " " + age;
};
fun4("Хулио", 35);
// или
const fun5 = (name,age) => name + " " + age;
fun5("Хулио", 1024);

const obj3 = {

    nameFirst: "Призрачный",
    fullName: function () {
        const self = this;
        function create() {
            let name = self.nameFirst + " " + "Самогонщик";
            return name;
        }
        return `${create()}`;
    }
};
obj3.fullName(); //"Призрачный Самогонщик"

//или
const ob = {

    nameFirst: "Призрачный",
    fullName: function () {
        const create = () => {
            let name = this.nameFirst + " " + "Самогонщик";
            return name;
        };
        return `${create()}`;
    }
};
ob.fullName();

//Немедленно вызываемые функциональные выражения---------------------------------------------------------------------

(function () {
    console.log('Немедленный вызов');
}) ();

const n = (function () {
    const mess = 'Немедленный вызов';
    return mess;
}) ();

console.log(n);

const f = (function() {
    let count = 0;
    return function () {
        return `Меня вызывали ${++count} раз`;
    }
}) ();

f();

// Вызов функции до ее создания---------------------------------------------------------------------------

name();
function name() {
    return 'Сэм';
}